// x86-64 Windows (Microsoft x64 calling convention) context switching
// implementation Adapted from llco (https://github.com/tidwall/llco) Copyright
// (c) 2024 Joshua J Baker.

#pragma once
#include "../basic_types.h"

#if (defined(__x86_64__) || defined(_M_X64)) && !defined(CHIBA_CO_NOASM) &&    \
    defined(_WIN32)
#define CHIBA_CO_ASM
#define CHIBA_CO_READY
#define CHIBA_CO_METHOD "asm,x64_windows"
NOINLINE PRIVATE void CHIBA_co_entry(anyptr arg) __attribute__((noreturn));

struct CHIBA_co_asmctx {
  anyptr rip, rsp, rbp, rbx, r12, r13, r14, r15, rdi, rsi;
  anyptr xmm[20]; /* xmm6, xmm7, xmm8, xmm9, xmm10, xmm11, xmm12, xmm13,
      xmm14, xmm15 */
  anyptr fiber_storage;
  anyptr dealloc_stack;
  anyptr stack_limit;
  anyptr stack_base;
};

#if defined(__GNUC__)
#define CHIBA_CO_ASM_BLOB __attribute__((section(".text")))
#elif defined(_MSC_VER)
#define CHIBA_CO_ASM_BLOB __declspec(allocate(".text"))
#pragma section(".text")
#endif

CHIBA_CO_ASM_BLOB PRIVATE u8 CHIBA_co_wrap_main_code_entry[] = {
    0x4c, 0x89, 0xe9,                                    // mov    %r13,%rcx
    0x41, 0xff, 0xe4,                                    // jmpq   *%r12
    0xc3,                                                // retq
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 // nop
};

CHIBA_CO_ASM_BLOB PRIVATE u8 CHIBA_co_asm_switch_code[] = {
    0x48, 0x8d, 0x05, 0x3e, 0x01, 0x00, 0x00,       // lea    0x13e(%rip),%rax
    0x48, 0x89, 0x01,                               // mov    %rax,(%rcx)
    0x48, 0x89, 0x61, 0x08,                         // mov    %rsp,0x8(%rcx)
    0x48, 0x89, 0x69, 0x10,                         // mov    %rbp,0x10(%rcx)
    0x48, 0x89, 0x59, 0x18,                         // mov    %rbx,0x18(%rcx)
    0x4c, 0x89, 0x61, 0x20,                         // mov    %r12,0x20(%rcx)
    0x4c, 0x89, 0x69, 0x28,                         // mov    %r13,0x28(%rcx)
    0x4c, 0x89, 0x71, 0x30,                         // mov    %r14,0x30(%rcx)
    0x4c, 0x89, 0x79, 0x38,                         // mov    %r15,0x38(%rcx)
    0x48, 0x89, 0x79, 0x40,                         // mov    %rdi,0x40(%rcx)
    0x48, 0x89, 0x71, 0x48,                         // mov    %rsi,0x48(%rcx)
    0x0f, 0x11, 0x71, 0x50,                         // movups %xmm6,0x50(%rcx)
    0x0f, 0x11, 0x79, 0x60,                         // movups %xmm7,0x60(%rcx)
    0x44, 0x0f, 0x11, 0x41, 0x70,                   // movups %xmm8,0x70(%rcx)
    0x44, 0x0f, 0x11, 0x89, 0x80, 0x00, 0x00, 0x00, // movups %xmm9,0x80(%rcx)
    0x44, 0x0f, 0x11, 0x91, 0x90, 0x00, 0x00, 0x00, // movups %xmm10,0x90(%rcx)
    0x44, 0x0f, 0x11, 0x99, 0xa0, 0x00, 0x00, 0x00, // movups %xmm11,0xa0(%rcx)
    0x44, 0x0f, 0x11, 0xa1, 0xb0, 0x00, 0x00, 0x00, // movups %xmm12,0xb0(%rcx)
    0x44, 0x0f, 0x11, 0xa9, 0xc0, 0x00, 0x00, 0x00, // movups %xmm13,0xc0(%rcx)
    0x44, 0x0f, 0x11, 0xb1, 0xd0, 0x00, 0x00, 0x00, // movups %xmm14,0xd0(%rcx)
    0x44, 0x0f, 0x11, 0xb9, 0xe0, 0x00, 0x00, 0x00, // movups %xmm15,0xe0(%rcx)
    0x65, 0x4c, 0x8b, 0x14, 0x25, 0x30, 0x00, 0x00,
    0x00,                                           // mov    %gs:0x30,%r10
    0x49, 0x8b, 0x42, 0x20,                         // mov    0x20(%r10),%rax
    0x48, 0x89, 0x81, 0xf0, 0x00, 0x00, 0x00,       // mov    %rax,0xf0(%rcx)
    0x49, 0x8b, 0x82, 0x78, 0x14, 0x00, 0x00,       // mov    0x1478(%r10),%rax
    0x48, 0x89, 0x81, 0xf8, 0x00, 0x00, 0x00,       // mov    %rax,0xf8(%rcx)
    0x49, 0x8b, 0x42, 0x10,                         // mov    0x10(%r10),%rax
    0x48, 0x89, 0x81, 0x00, 0x01, 0x00, 0x00,       // mov    %rax,0x100(%rcx)
    0x49, 0x8b, 0x42, 0x08,                         // mov    0x8(%r10),%rax
    0x48, 0x89, 0x81, 0x08, 0x01, 0x00, 0x00,       // mov    %rax,0x108(%rcx)
    0x48, 0x8b, 0x82, 0x08, 0x01, 0x00, 0x00,       // mov    0x108(%rdx),%rax
    0x49, 0x89, 0x42, 0x08,                         // mov    %rax,0x8(%r10)
    0x48, 0x8b, 0x82, 0x00, 0x01, 0x00, 0x00,       // mov    0x100(%rdx),%rax
    0x49, 0x89, 0x42, 0x10,                         // mov    %rax,0x10(%r10)
    0x48, 0x8b, 0x82, 0xf8, 0x00, 0x00, 0x00,       // mov    0xf8(%rdx),%rax
    0x49, 0x89, 0x82, 0x78, 0x14, 0x00, 0x00,       // mov    %rax,0x1478(%r10)
    0x48, 0x8b, 0x82, 0xf0, 0x00, 0x00, 0x00,       // mov    0xf0(%rdx),%rax
    0x49, 0x89, 0x42, 0x20,                         // mov    %rax,0x20(%r10)
    0x44, 0x0f, 0x10, 0xba, 0xe0, 0x00, 0x00, 0x00, // movups 0xe0(%rdx),%xmm15
    0x44, 0x0f, 0x10, 0xb2, 0xd0, 0x00, 0x00, 0x00, // movups 0xd0(%rdx),%xmm14
    0x44, 0x0f, 0x10, 0xaa, 0xc0, 0x00, 0x00, 0x00, // movups 0xc0(%rdx),%xmm13
    0x44, 0x0f, 0x10, 0xa2, 0xb0, 0x00, 0x00, 0x00, // movups 0xb0(%rdx),%xmm12
    0x44, 0x0f, 0x10, 0x9a, 0xa0, 0x00, 0x00, 0x00, // movups 0xa0(%rdx),%xmm11
    0x44, 0x0f, 0x10, 0x92, 0x90, 0x00, 0x00, 0x00, // movups 0x90(%rdx),%xmm10
    0x44, 0x0f, 0x10, 0x8a, 0x80, 0x00, 0x00, 0x00, // movups 0x80(%rdx),%xmm9
    0x44, 0x0f, 0x10, 0x42, 0x70,                   // movups 0x70(%rdx),%xmm8
    0x0f, 0x10, 0x7a, 0x60,                         // movups 0x60(%rdx),%xmm7
    0x0f, 0x10, 0x72, 0x50,                         // movups 0x50(%rdx),%xmm6
    0x48, 0x8b, 0x72, 0x48,                         // mov    0x48(%rdx),%rsi
    0x48, 0x8b, 0x7a, 0x40,                         // mov    0x40(%rdx),%rdi
    0x4c, 0x8b, 0x7a, 0x38,                         // mov    0x38(%rdx),%r15
    0x4c, 0x8b, 0x72, 0x30,                         // mov    0x30(%rdx),%r14
    0x4c, 0x8b, 0x6a, 0x28,                         // mov    0x28(%rdx),%r13
    0x4c, 0x8b, 0x62, 0x20,                         // mov    0x20(%rdx),%r12
    0x48, 0x8b, 0x5a, 0x18,                         // mov    0x18(%rdx),%rbx
    0x48, 0x8b, 0x6a, 0x10,                         // mov    0x10(%rdx),%rbp
    0x48, 0x8b, 0x62, 0x08,                         // mov    0x8(%rdx),%rsp
    0xff, 0x22,                                     // jmpq   *(%rdx)
    0xc3,                                           // retq
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, // nop
    0x90, 0x90,                                     // nop
};

void (*_CHIBA_co_asm_entry)(void) = (void (*)(void))(anyptr)
    CHIBA_co_wrap_main_code_entry;
void (*_CHIBA_co_asm_switch)(struct CHIBA_co_asmctx *from,
                             struct CHIBA_co_asmctx *to) =
    (void (*)(struct CHIBA_co_asmctx *from,
              struct CHIBA_co_asmctx *to))(anyptr)CHIBA_co_asm_switch_code;

// Windows x64 implementation
PRIVATE void CHIBA_co_asmctx_make(struct CHIBA_co_asmctx *ctx,
                                  anyptr stack_base, u64 stack_size,
                                  anyptr arg) {
  stack_size = stack_size - 32; // Reserve 32 bytes for the shadow space.
  anyptr *stack_high_ptr =
      (anyptr *)((u64)stack_base + stack_size - sizeof(u64));
  stack_high_ptr[0] = (anyptr)(0xdeaddeaddeaddead); // Dummy return address.
  ctx->rip = (anyptr)(_CHIBA_co_asm_entry);
  ctx->rsp = (anyptr)(stack_high_ptr);
  ctx->r12 = (anyptr)(CHIBA_co_entry);
  ctx->r13 = arg;
  anyptr stack_top = (anyptr)((u64)stack_base + stack_size);
  ctx->stack_base = stack_top;
  ctx->stack_limit = stack_base;
  ctx->dealloc_stack = stack_base;
}

#endif // __x86_64__ && _WIN32
